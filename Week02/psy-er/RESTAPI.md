# 발표 준비 자료

**발표목표**

프로젝트 하는데 MVC만 사용하지 말고 프론트, 백엔드 REST API로 통신해라

![Untitled](%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%20%E1%84%8C%E1%85%AE%E1%86%AB%E1%84%87%E1%85%B5%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%207b10e022a73e4934a2c4e27792146b2c/Untitled.png)

**Rest API 발표 목차**

- 프로젝트 시작 웹 기초 (프론트엔드, 백엔드)
- 등장배경 (과거 Monolithic, MVC 방식은 개발자가 화명 + 데이터를 모두 담당)

화면 디테일 → 지금은 화면개발자(프론트), 서버개발자(백엔드)가 분리됨

따라서 둘의 통신 필요성 어떻게? → 규약이 REST API

- HTTP 메서드
- 웹 애플리케이션 아키텍처
- JSON
- API 정의
- REST 정의
- Rest API

**참고자료**

[https://www.youtube.com/watch?v=RP_f5dMoHFc&t=1791s](https://www.youtube.com/watch?v=RP_f5dMoHFc&t=1791s)

테코톡 참고하기

쉬운코드 (수준이 좀 더 높다 → 쉽게 설명할 생각 하기)

## 웹기초(프론트엔드, 백엔드, ~~AWS~~)

- **HTML/CSS/Javascript/React** : 프론트엔드 애플리케이션 개발에 사용,

프론트엔드 애플리케이션은 프론트엔드 클라이언트를 반환하는 서버가 존재한다.

프론트엔드에서 반환하는 서버의 역할은 단 한가지

→ 프론트엔드 프레임워크 애플리케이션을 반환하는 것

프론트엔드가 하는 역할 : UI 개발

- **JAVA/Javascript/python/Spring Boot / Node.js** : 백엔드 애플리케이션 개발에 사용.

대체로 스프링 부트를 사용하여 Rest API를 구현한다.

(Rest API에 대해서는 이후에 더 자세하게 설명하겠습니다)

웹 애플리케이션 배포 이후, 앱 애플리케이션을 배포하고자 할 때, 

별도의 백엔드 개발을 할 필요 없이 백엔드 애플리케이션의 Rest API를 사용할 수 있다.

백엔드가 하는 역할 : 핵심 기능 개발

- **백엔드와 프론트엔드 분리**

백엔드와 프론트엔드를 분리하는 것의 이점 : 

마이크로서비스 아키텍처로 서비스를 확장하는데 용이

- **마이크로서비스란?**

하나의 프로그램을 여러개의 서비스로 나누는 것.

## **웹 애플리케이션 아키텍처**

사진 버리기

![Untitled](%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%20%E1%84%8C%E1%85%AE%E1%86%AB%E1%84%87%E1%85%B5%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%207b10e022a73e4934a2c4e27792146b2c/Untitled%201.png)

- 아키텍처란? 전체 구조를 뜻합니다.

백엔드 프론트엔드를 나눠서 개발을 합니다.
서버는 프론트엔드 서버와 백엔드 서버 두 종류로 나뉘어져 있습니다.
프론트엔드 서버는 사용자에게 User InterFace를 제공해주는 서버입니다.
백엔드 서버는 비즈니스 로직, 즉 핵심 기능을 제공해주는 서버입니다.
백엔드는 MySQL RDS 데이터베이스를 사용하여 회원정보 등을 저장합니다.

프론트엔드 서버와 백엔드 서버는 여러개가 존재할 수 있습니다.
서버의 부하를 방지하기 위해서는 여러 인스턴스를 두는 것이 좋습니다.

사용자가 늘수록 인스턴스의 개수도 늘어납니다.
인스턴스의 개수를 자동적으로 관리하는 것이 오토 스케일링이라고 합니다.

애플리케이션 로드 밸런서는 요청 받은 신호를 어느 인스턴스에 보내줄지 결정합니다.

AWS에서는 로드밸런서와 오토 스케일링 기능을 제공합니다.

프론트엔드 서버와 백엔드 서버의 접근 제한을 위해 VPC(고객 전용 사설 네트워크) 제공

Route 53은 AWS에서 IP Address를 관리하는 서비스입니다.

그 이후

1. 도메인 생성
2. IP 주소 얻기 (Route 53에서)
3. 클라이언트가 GET 요청을 보냄
4. 프론트엔드에서 User Interface를 불러옴
5. 백엔드에서 핵심 기능 API를 불러옴
6. 대체로 백엔드 서버 개발을 한 뒤에 프론트엔드 서버 개발을 진행함
7. 

클라이언트의 유저 인터페이스는 프론트엔드에서 받고
클라이언트에서 액션이 일어날 때 마다 주요 핵심기능을 백엔드에서 받는다

- **~~AWS~~**

~~프론트엔드와 백엔드 애플리케이션이 실행될 프로덕션 환경을 구축하기 위해 사용~~

## ~~HTTP (HyperText Transfer Protocol)~~

![Untitled](%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%20%E1%84%8C%E1%85%AE%E1%86%AB%E1%84%87%E1%85%B5%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%207b10e022a73e4934a2c4e27792146b2c/Untitled%202.png)

- **~~HTTP**  : 하이퍼텍스트를 주고받기 위한 통신 규약,~~

~~클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜이다.~~ 

![Untitled](%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%20%E1%84%8C%E1%85%AE%E1%86%AB%E1%84%87%E1%85%B5%20%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%207b10e022a73e4934a2c4e27792146b2c/Untitled%203.png)

~~클라이언트인 웹사이트 내에서 링크나 버튼을 클릭하게 되면, 서버 쪽으로 요청이 간다.~~

~~서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달하게 된다.~~

- HTTP 메서드
- 응답 코드

## REST

**REST란? 추상적인 개념?**

REST : REpresentational State Transfer

REST : a way of providing interoperability(상호운용성) between computer
systems on the internet

**WEB(1991)**
등장 배경 : 어떻게 인터넷에서 정보를 공유할 것인가?
팀버너스리의 답 : 정보들을 하이퍼텍스트로 연결한다.
표현방식 : HTML
식별자 : URI
전송방법 : HTTP (프로토콜)

**HTTP/1.0(1994-1996)**
Roy.T.Fielding : How do I improve HTTP without breaking the Web?

HTTP를 정의하게 된다면 기존에 구축되어진 웹과 호환성 문제가 생기는 것을 피하고 싶음
해결방법 : HTTP Object Model

HTTP Object Model -> 지금의 REST으로 발전되었다

## API

**XML-RPC**

XML-RPC : Microsoft가 원격으로 다른 시스템에 메소드를 호출할 수 있는 프로토콜을 만듦
XML-RPC -> SOAP 명칭 변경

**REST 논문이 나온 후 SOAP과의 비교**

SOAP
-복잡하다
-규칙이 많다
-어렵다

REST
-단순하다
-규칙이 적다
-쉽다

**REST의 인기 상승, REST의 승리**

2006년, AWS가 자사 API의 사용량의 85%가 REST임을 밝힘

2010년, Salesforce.com, REST API 추가

---

---

---

---

---

---

## **REST인가 아닌가?**

다른 사람들과 로이 필딩의 정의가 다르다!

**바인딩?**

바인딩(Binding)이란 프로그램의 어떤 기본 단위가 가질 수 있는 구성요소의 구체적인 값, 성격을 확정하는 것을 말한다.

ex) int num = 123; 

int는 자료형, num 변수이름, 123 자료값 

이와 같이 각각의 구체적인 값을 할당하는 것을 바인딩이라고 한다.

**버저닝?**

API를 개발하면 시간에 따라 버전이 올라가는 것이 당연하다.
서버 운영을 하면서 서버의 API가 수정되거나 추가되는 것은 불가피하게 발생된다.
이렇듯 API가 변경될 때마다 오류들이 새로 나타날 수 있다.
그때마다 클라이언트의 버전을 업데이트하라고 강제성을 띄우기 보다는 API 버전 관리가 필요하다.
버저닝은 기존 API를 사용자에게 안정적으로 제공하면서, 새로운 버전의 API를 추가로 제공하여
사용자가 API의 버전을 선택 할 수 있도록하는 기술을 말한다.

**CMIS (2008)**
-CMS를 위한 표준
-EMC, IBM, Microsoft등이 함께 작업
-REST 바인딩 지원!!

REST 창시자 Roy.T.Fielding 왈
"NO REST in CMIS"

**Microsoft REST API Guidelines (2016)**

-uri는 https://{serviceRoot}/{collection}/{id} 형식이어야 한다

-GET,PUT,DELETE,POST,HEAD, PATCH, OPTIONS을 지원해야 한다

-API 버저닝은 Major.minor로 하고 uri에 버전 정보를 포함시킨다

>> 사람들은 좋은 REST API에 부합한다고 생각함

하지만 로이 필딩은 REST API임을 반대

**로이필딩의 REST API 설명**

1. REST API는 hypertext-driven이어야 한다고 권고, REST API는 hypertext가 주도해야만 해
2. REST API를 위한 최고의 버저닝 전략은 버저닝을 안하는 것이다.

## REST 아키텍쳐 스타일의 6가지 제약조건

REST 아키텍쳐란 웹에서 데이터를 주고받는 스타일을 의미합니다.

**1) 클라이언트-서버(Client-Server)**

리소스 : REST API가 리턴할 수 있는 모든 것. HTML, JSON, 이미지 등

리소스를 소비하려는 다수의 클라이언트가 네트워크를 통해 서버에 접근하는 구조로 웹 애플리케이션이 여기에 해당 됩니다.

사용자들에게 제공하는 interface인 User Interface와 데이터 스토리지, 알고리즘 등 서버 내부의 작업들을 분리함으로 써 UI는 여러 플랫폼에서의 이식성을 높이고, 서버는 그 구성요소를 단순화하여 확장 가능하도록 하였습니다. 클라이언트는 서버의 리소스 URI만 알고 있으면 되기 때문에 이 제약 조건에 의해 클라이언트와 서버가 서로 독립적으로 진화할 수 있게 되었습니다.

**2) 상태가 없는 (Stateless)**

클라이언트가 서버에 요청을 보낼 때 이전 요청의 영향을 받지 않음을 의미합니다. 서버는 클라이언트의 요청을 처리한 후 상태를 보관하지 않고, 요청 시마다 서로 다른 요청으로 인식되어 이전 작업 내용을 다음 요청 시 사용할 수 없습니다.

ex) 로그인 후 그 다음 요청 시, 서버는 이전 요청에서 로그인한 사실을 모릅니다. 서버는 로그인 상태를 유지하지 못하므로 클라이언트는 요청을 보낼 때 마다 로그인 정보를 항상 함께 보내야 합니다.

서버가 리소스를 수정한 후 그 상태를 유지해야 하는 경우에는, 데이터베이스와 같은 퍼시스턴스에 상태를 저장해야 합니다. HTTP는 기본적으로 상태가 없는 프로토콜이고, 불특정 다수의 클라이언트가 요청하기 때문에 웹에서는 이전 요청 시의 상태를 유지 할 수 없습니다.

**클라이언트에서 서버로의 각 요청에는 그 요청을 이해하는 데 필요한 모든 정보가 포함**되어야 합니다. 서버에 저장된 환경 정보를 이용해서 이득 ex) 서버에서의 클라이언트 정보 유지 등을 취하면 안 됩니다. 따라서 세션의 정보는 전적으로 클라이언트가 가지고 있어야 합니다. 로그인했다는 세션 유지가 필요하다면 그 정보 또한 Client가 해당 정보를 가지고 서버에 전달해야 합니다. ex) JWT 사용

**3) 캐시되는 (cacheable) 데이터**

캐싱 : 주어진 리소스의 복사본을 저장하고 있다가 요청 시에 그것을 제공하는 기술

서버에서 리소스를 리턴할 때 캐시가 가능한지 아닌지 명시할 수 있어야 합니다. HTTP에서는 cache-control 이라는 헤더를 통해 리소스의 캐시 여부를 명시합니다.

1. 서버의 응답(복사본)을 cache에 보관하고
2. 동일한 요청 시 cache에 있던 응답(복사본)을 리턴합니다

**요청에 대한 응답 내의 데이터에 해당 요청은 캐시가 가능한지 불가능 한지 명시해야 합니다.** 응답을 캐시 할 수 있다면 클라이언트에서 동일한 요청이 왔을 때 응답 데이터를 재사용할 수 있어야 합니다. 

**4) 일관적인 인터페이스 (Uniform Interface)**

리소스에 대한 식별자, 리소스에 접근하는 방식, 요청 형식, 응답 형식 등이 애플리케이션 전반에 걸쳐 일반적이어야 합니다. 요청 또는 응답 메시지는 리소스를 변경, 삭제할 수 있는 충분한 정보를 가져야 합니다.

ex) Todo 아이템의 경우 id를 클라이언트에 전달해야 Todo 아이템을 변경/삭제할 수 있습니다.

**전체적인 시스템 아키텍처를 간단하고 잘 파악할 수 있도록 약속된 Interface**, 해당 규약을 REST하게 사용자들이 지킴으로써 추후에 사용하는 Client를 개발하는 사용자와 Server를 개발하는 사용자 간의 결합도가 낮아질 수 있습니다. Uniform interface 개발 REST 규약으로 4가지를 제시합니다.

- identification of resources
- manipulation of resources through representations
- self-descriptive messages
- hypermedia as the engine of application state.

**5) 레이어드 시스템 (Layered System)**

서버는 여러개의 레이어로 구성될 수 있으며 확장이 가능합니다.

인증 서버, 캐싱 서버, 로드 밸런서 등 여러 서버를 둘 수 있습니다.

클라이언트는 서버의 레이어 존재 유무를 알지 못합니다.

계층화된 시스템 아키텍처를 사용하여 **각 구성들 간의 계층을 마음대로 상호작용 할 수 없도록 제한** 함으로 써 Interface를 일원화할 수 있습니다.

**6) 코드-온-디맨드 (Code-On-Demand)** 

서버가 네트워크를 통해 클라이언트에 전달한 javascript 등과 같은 프로그램들은 그 자체로 실행이 될 수 있어야 합니다. 이것은 사전 구현에 필요한 기능의 수를 줄임으로써 클라이언트를 단순화 시키는 것으로 우리가 평소 정적인 데이터를 xml 또는 json에 담아서 client로 보내고, client가 이것을 가공하는 것이 아닌 **client에 보내는 데이터를 바로 실행 가능한 코드처럼 보내 이를 Client에서 실행하는 것**을 말합니다.

## REST API

**REST API**

REST API : REST 아키텍쳐 스타일을 따르는 API이다.

REST : 분산 하이퍼미디어 시스템을 (ex) 웹) 위한 아키텍쳐 스타일

아키텍쳐 스타일 : 제약조건의 집합

**아키텍쳐 스타일, 즉 모든 제약조건을 지켜야 REST를 따른다고 할 수 있다.**

**REST를 구성하는 스타일**

- client-server
- stateless
- cache
- **uniform interface (지켜지기 어려운 제약 조건)**
- layered system
- code-on-demand(optional)

      서버에서 코드를 클라이언트로 보내서 실행할 수 있어야함 javascript

HATEOAS 예시 나열……

**HATEOAS / 독립적 진화 필수적**

- 서버와 클라이언트가 각각 독립적으로 진화한다
- 서버의 기능이 변경되어도 클라이언트를 업데이트 할 필요가 없다

**REST가 잘 적용된 사례 : 웹**

- 웹 페이지를 변경했다고 웹 브라우저를 업데이트 할 필요는 없다
- 웹 브라우저를 업데이트 했다고 웹 페이지를 변경할 필요도 없다
- HTTP 명세가 변경되어도 웹은 잘 동작한다
- HTML 명세가 변경되어도 웹은 잘 동작한다

**웹의 상호운용성(interoperability)에 대한 집착**

- Referer 오타지만 안 고침
- charset 잘못 지은 이름이지만 안 고침
- HTTP 상태 코드 416 포기함 (I’m a teapot, 만우절 장난)
- HTTP/0.9 아직도 지원함 (크롬에서 빼려고 시도 but 곳곳에서 프록시 오류 발생)

**REST가 웹의 독립적 진화에 도움을 주었는가**

- HTTP에 지속적으로 영향을 주었음
- HOST 헤더 추가
- 길이 제한을 다루는 방법이 명시 되었음 (414 URI Too Long)
- URI에서 리소스의 정의가 추상적으로 변경됨
- 기타 HTTP와 URI에 많은 영향을 줌
- HTTP/1.1 명세 최신판에서 REST에 대한 언급이 들어감
- Reminder:Roy T.Fielding이 HTTP와 URI 명세 저자 중 한명이다. > 지맘대로 만듦

## REST는 성공했는가?

- REST는 웹의 독립적 진화를 위해 만들어졌다
- 웹은 독립적으로 진화하고 있다

**결론 : REST는 성공하였다!!**

## REST API는 성공했는가?

- REST API는 REST 아키텍쳐 스타일을 따라야한다
- 오늘날 스스로 REST API라고 하는 API들의 대부분이 REST 아키텍쳐 스타일을 따르지 않는다

REST API도 제약조건들을 다 지켜야 하는가?

그렇다.

REST API란 하이퍼텍스트를 포함한 self-descriptive한 메시지의 unifrom interface를 통해 

리소스에 접근하는 API이다.

REST API는 self-descriptive와 HATEOAS를 지켜야 한다.

REST API를 무조건 사용해야 하는가?

사용 안해도 돼~~~~~~~~~~~~~~~~~~~~~~~~

>>> 시스템 전체를 통제할 수 있다고 생각하거나, 진화에 관심이 없다면,

REST에 대해 따지느라 시간 낭비하지 마라.

닥치고 사용해라~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**현재상태**

1. **REST API 구현하고 REST API라고 부르기 (도전)**
2. REST API 구현을 포기하고 HTTP API라고 부르기
3. **REST API가 아니지만 REST API라고 부르기 (현재 상태)**

## 왜 API는 REST가 잘 안되나?

일반적인 웹과 비교

|  | 웹페이지 | HTTP API |
| --- | --- | --- |
| Protocol | HTTP | HTTP |
| 커뮤니케이션 | 사람-기계 | 기계-기계 |
| Media Type | HTML | JSON |

**REST API가 실패한 이유 : 커뮤니케이션, Media Type**

1. 커뮤니케이션

|  | HTML | JSON |
| --- | --- | --- |
| Hyperlink | 가능(a태그) | 불가능 |
| Self-descriptive | 가능(html 명세) | 불완전 |

Json이 불완전하다는 의미 : 대괄호, 중괄호 파싱, 배열 해석은 가능하지만 그 안에 있는 값이 무엇인지는 정의되지 않음.

따라서 JSON의 문법 해석은 가능하지만, 의미를 해석하려면 별도로 API 문서가 필요하다 .

HTTP JSON 예시 나열…………

HTML은 REST를 성공하였다. 

하지만 JSON은 REST를 성공하지 못하였다.

## 독립적인 진화에 도움

그런데 self-descriptive와 HATEOAS가 독립적인 진화에 어떻게 도움이 될까요?

Self-descriptive

self-descriptive는 확장 가능한 커뮤니케이션을 가능하게 한다.

서버나 클라이언트가 변경되더라도 오고 가는 메시지는 언제나 self-descriptive( 메세지만으로도 해석이 가능하다) 하므로 언제나 해석이 가능하다.

방법 1. Media type

1) 미디어 타입을 하나 정의한다

2) 미디어 타입 문서를 작성한다. 이 문선에 “id”가 뭐고 “title”이 뭔지 의미를 정의한다.

3) IANA에 미디어 타입을 등록한다. 이 때 만든 문서를 미디어 타입의 명세로 등록한다.

4) 이제 이 메시지를 보는 사람은 명세를 찾아갈 수 있으므로 이 메시지의 의미를 온전히 해석할 수 있다.

단점 : 매번 media type을 정의해야 한다

방법 2. Profile

정보의 의미가 담긴 링크를 첨부할 수 있음 → 릴레이션을 프로필함 

1) “id”가 뭐고 “title”이 뭔지 의미를 정의한 명세를 작성한다.

2) Link 헤더에 profile relation으로 해당 명세를 링크한다

3) 이제 메시지를 보는 사람은 명세를 찾아갈 수 있으므로 이 문서의 의미를 온전히 해석할 수 있다.

단점 : 클라이언트가 link 헤더(RFC 5988)와 profile 릴레이션(RFC 6906)을 이해해야 한다. 

미디어 타입으로 했을 때는  클라이언트의 지원이 없을 때 서버가 알아챌 수 있지만,  프로파일은 오로지 링크로만 판단을 하여 Content negotiation을 할 수 없다. 

HATEOAS

HATEOAS 애플리케이션 상태 전이의 late binding이 가능

어디서 어디로 전이가 가능한지 미리 결정되지 않는다. 어떤 상태로 전이가 완료되고 나서야 그 다음 전이될 수 있는 상태가 결정된다. 쉽게 말해서: 링크는 동적(마음대로)으로 변경할 수 있다.

서버가 링크를 바꿔도 클라이언트 동작에는 전혀 문제가 없다.

방법 1. data로

data에 다양한 방법으로 하이퍼링크를 표현한다.

JSON으로 하이퍼링크를 표현하는 방법을 정의한 명세들을 활용한다.

JSON API, HAL ,UBER ,Siren..

단점 : 기존 API를 많이 고쳐야한다. (침투적)

방법 2. HTTP 헤더로

Link, Location 등의 헤더로 링크를 표현한다.

단점 : 정의된 relation만 활용한다면 표현에 한계가 있다.

⇒ HATEOAS는 data와 헤더를 모두 활용하면 좋다.

**Hyperlink는 반드시 uri여야 하는가?**

uri - https://toss.im/users/eungjun

uri reference (absolute) - /users/eungjun

uri reference (relative) - eungjun

uri template - /users/{username}

**Media type 등록은 필수인가?**

- no
- 하지만 하면 좋다

**Media type을 IANA에 등록하기**

- 누구나 쉽게 사용할 수 있게 된다
- 이름 충돌을 피할 수 있다
- 등록이 별로 어렵지 않다(고 주장함)

**정리**

오늘날 대부분의 “REST API”는 사실 REST를 따르지 않고 있다.

REST의 제약조건 중에서 특히 Self-descriptive와 HATEOAS를 잘 만족하지 못한다.

REST는 긴 시간에 걸쳐 (수십년) 진화하는 웹 애플리케이션을 위한 것이다.

REST를 따를 것인지는 API를 설계하는 이들의 스스로 판단하여 결정해야한다.

REST를 따르겠다면, Self-descriptive와 HATEOAS를 만족시켜야한다.

- self-descriptive는 custom media type이나 profile link relation 등으로 만족시킬 수 있다.
- HATEOAS는 HTTP 헤더나 본문에 링크를 담아 만족시킬 수 있다.

REST를 따르지 않겠다면, “REST를 만족하지 않는 REST API”를 뭐라고 부를지 결정해야 한다.

- HTTP API라고 부를 수도 있고
- 그냥 이대로 REST API라고 부를 수도 있다. (roy 필딩이 싫어한다)

발표 10-15분

워드 꽉 채워서 2장 (대본)

미리캔버스